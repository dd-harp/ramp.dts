<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Blood feeding</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>







<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Blood feeding</h1>



<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>Blood feeding (when a adult female mosquito seeks out and feeds on a
blood host) is a crucial <em>invariant</em> in
<strong>Micro-MoB</strong>, and models of mosquito-borne pathogen
transmission (MBPT) generally. Blood feeding is an algorithm which uses
information provided by the interface from each component to compute
values which give the distribution of bites from mosquitoes onto hosts,
and the rate that mosquitoes feed. The blood feeding function
(<code>compute_bloodmeal()</code>) is in <code>R/bloodmeal.R</code>.</p>
</div>
<div id="schematic" class="section level2">
<h2>Schematic</h2>
<p>Below is a schematic describing visually the quantities that are
generated in the blood meal algorithm. Different colors refer to
different components: green indicates values from the human component,
blue indicates values from the adult mosquito component, and yellow
indicates values from the other blood hosts and visitor components.</p>
<p>Values which are computed by the blood meal which are not directly
involved with transmission are in red, and values that are directly
relevant for transmission are in grey.</p>
<p>The bloodmeal function updates several values within specific
components. Those are:</p>
<ul>
<li><span class="math inline">\(\kappa\)</span>: a vector of length
<code>p</code>, giving the net infectiousness of hosts to mosquitoes in
each patch (adult mosquito component).</li>
<li><span class="math inline">\(EIR\)</span>: a vector of length
<code>n</code>, giving the entomological inoculation rate on hosts in
each strata (human component).</li>
<li><span class="math inline">\(f\)</span>: a vector of length
<code>p</code>, giving the blood feeding rate of mosquitoes in each
patch (adult mosquito component).</li>
<li><span class="math inline">\(q\)</span>: a vector of length
<code>p</code>, giving the proportion of blood meals taken on human
hosts by mosquitoes in each patch (adult mosquito component).</li>
</ul>
<p>After these values have been computed, each component’s update (step)
function can use them to update infection in the population. These four
values are the crucial metrics that describe how mosquitoes feed upon
hosts, and how pathogens are transferred between infectious hosts to
susceptible mosquitoes, and vice versa. For this reason we call
bloodfeeding an invariant component, meaning any full MBPT model will
need to simulate this process.</p>
</div>
<div id="human-component" class="section level2">
<h2>Human component</h2>
<p>Using the generic interface from the human component, the following
values are calculated which are used to compute biting and
transmission.</p>
<ul>
<li><code>H</code>: from <code>compute_H</code>, gives the total
population in each strata</li>
<li><code>x</code>: from <code>compute_x</code>, gives the net
infectiousness from humans in each strata</li>
<li><code>wf</code>: from <code>compute_wf</code>, gives the biting
weights of each strata</li>
<li><code>Psi</code>: from <code>compute_Psi</code>, gives the time at
risk matrix</li>
<li><code>W</code>: gives the weighted person time at risk spent at each
patch; please note <code>W</code> is calculated from the above values
(rather than from a dispatching method)</li>
</ul>
</div>
<div id="mosquito-component" class="section level2">
<h2>Mosquito component</h2>
<p>Likewise, the following values are required from the mosquitoes.</p>
<ul>
<li><code>f</code>: from <code>compute_f</code>, gives the per-capita
blood feeding rate in each patch</li>
<li><code>q</code>: from <code>compute_q</code>, gives the human blood
feeding proportion in each patch</li>
<li><code>Z</code>: from <code>compute_Z</code>, gives the infectious
mosquito density in each patch</li>
</ul>
</div>
<div id="other-components" class="section level2">
<h2>Other components</h2>
<p>We also need to compute:</p>
<ul>
<li><code>Wd</code>: from <code>compute_Wd</code>, the biting
availability of visitors in each patch</li>
<li><code>O</code>: from <code>compute_O</code>, the biting availability
of other blood hosts in each patch</li>
<li><code>xd</code>: from <code>compute_xd</code>, the net
infectiousness of visitors in each patch</li>
</ul>
</div>
<div id="biting-distribution-matrix-beta" class="section level2">
<h2>Biting distribution matrix (<span class="math inline">\(\beta\)</span>)</h2>
<p><span class="math inline">\(\beta\)</span>, the biting distribution
matrix, is an <code>n</code> by <code>p</code> matrix which describes
how bites from mosquitoes in patches get distributed over human
population strata. If it is multiplied on the right by a vector <span class="math inline">\(fq \upsilon Z\)</span> which gives the total
number of bites on humans taken by mosquitoes in each patch, the result
is a length <code>n</code> vector giving the per-capita <span class="math inline">\(EIR\)</span>.</p>
<p><span class="math display">\[\begin{equation}
\beta_{n\times p} = \mbox{diag}(w_{f}) \cdot \Psi \cdot \mbox{diag}(1/W)
\\
\end{equation}\]</span></p>
</div>
<div id="entomological-inoculation-rate-eir" class="section level2">
<h2>Entomological inoculation rate (<span class="math inline">\(EIR\)</span>)</h2>
<p>The entomological inoculation rate is directly proportional to the
force of infection in humans <span class="math inline">\(h = EIR \cdot
b\)</span>, where <span class="math inline">\(b\)</span> is the
transmission efficiency, the probability a bite from an infectious
mosquito successfully causes infection in a human host. It is simply
computed as:</p>
<p><span class="math display">\[\begin{equation}
EIR_{n\times 1} = \beta \cdot fq\upsilon Z
\end{equation}\]</span></p>
</div>
<div id="net-infectiousness-of-the-human-population-kappa" class="section level2">
<h2>Net infectiousness of the human population (<span class="math inline">\(\kappa\)</span>)</h2>
<p>The net infectiousness of humans is the probability that a mosquito
would become infected after biting a random human host. It’s directly
proportional the force of infection in mosquitoes, which is <span class="math inline">\(\kappa fq\)</span>. After being calculated and
passed to the mosquitoes, any particular mosquito model can use it to
update state over a time step.</p>
<p><span class="math display">\[\begin{equation}
\kappa_{p\times 1} = \upsilon \cdot (\beta^{\top} \cdot xH) + (1 -
\upsilon) x_{\delta}
\end{equation}\]</span></p>
</div>
<div id="directed-wiring-diagram" class="section level2">
<h2>Directed wiring diagram</h2>
<p>Another way to view the bloodmeal computation is as a <a href="https://www.algebraicjulia.org/blog/post/2021/01/machines/">directed
wiring diagram (DWD)</a>. In this DWD there are two types of “boxes”,
rectangles and circles. Rectangles are elements of the model with state,
similar to machines in automata theory. Circles represent functions
which do not have internal state, but may take some number of inputs and
produce and output. Circles which are inside of a rectangle represent
functions that “belong” to that rectangle.</p>
<p>Putting this back in terms of <strong>Micro-MoB</strong>, rectangles
are components and circles are either <em>invariant</em> functions (if
they live outside of a box), or are methods that dispatch depending on
what model fills their component (if they live inside of a box).</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
